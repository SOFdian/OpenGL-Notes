### 帧缓冲

用于写入颜色值的**颜色缓冲**、用于写入深度信息的**深度缓冲**和允许我们根据一些条件丢弃特定片段的**模板缓冲**。这些缓冲结合起来叫做**帧缓冲**，它被储存在**显存**中

### 创建帧缓冲

创建一个帧缓存对象$FBO$

![image-20250505144442399](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250505144442399.png)

所有的**读取**和**写入**帧缓冲的操作将会影响当前绑定的帧缓冲

也可以分开来操作：

- $GL\_READ\_FRAMEBUFFER$：读取操作会从这个帧缓冲中读取数据，如$glReadPixels$
- $GL\_DRAW\_FRAMEBUFFER$：这种帧缓冲将会被用作渲染、清除等写入操作的目标

通常情况下还是使用默认那个帧缓冲，既读又写

![image-20250505144357892](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250505144357892.png)

- 添加一个颜色附件：
  ![image-20250506112241394](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250506112241394.png)
  主要区别在于$glTexImage2D$函数，之前设置的宽高（参数4,5)是纹理的宽高，现在是窗口的宽高；之前最后一个参数传入的是纹理图像的数据，现在传入的是$NULL$；
  同时新增了$glFramebufferTexture2D$函数，其参数如下：
  ![image-20250506112950381](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250506112950381.png)

- 添加一个渲染缓冲对象附件：

  渲染缓冲对象RBO，可以看成是一个只写不读的图像缓存，主要是用于存储深度和模板缓冲，主要特点是**不可采样**和**效率高**。

  - 尽量与纹理附件结合使用，**纹理存储颜色，RBO 存储深度和模板**
  - 不要试图从 RBO 中读取像素或传给 shader（会失败）

  ![image-20250506113248646](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250506113248646.png)
  

- 

