### 深度缓冲

- 深度缓冲是在片段着色器运行之后（以及模板测试运行之后）,在屏幕空间中运行的
- 可以直接使用GLSL内建变量$gl_FragCoord$从片段着色器中直接访问
- $gl_FragCoord$的x和y分量代表了片段的屏幕空间坐标（其中(0, 0)位于左下角）。$gl_FragCoord$中也包含了一个z分量，它包含了片段真正的深度值。z值就是需要与深度缓冲内容所对比的那个值。
- <img src="C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250427172920415.png" alt="image-20250427172920415"  />





深度缓冲用于防止被阻挡的面渲染到其它面的前面

当深度测试被启用的时候，OpenGL笔记会将一个片段的深度值与深度缓冲的内容进行对比。

OpenGL笔记会执行一个深度测试，如果这个测试通过了的话，深度缓冲将会更新为新的深度值。

如果深度测试失败了，片段将会被丢弃。

![image-20250427165601819](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250427165601819.png)

启用深度测试



![image-20250427165612200](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250427165612200.png)

在每个渲染循环中，都应该清除一下各种缓冲，否则就会使用到上一帧中的深度缓冲

![image-20250427170056706](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250427170056706.png)

![image-20250427170105820](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250427170105820.png)

用于控制使用怎么样的深度测试策略

### 深度值精度

观察空间的z值可能是投影平截头体的**近平面**和**远平面**之间的任何值。

深度缓冲包含了一个介于0.0和1.0之间的深度值。

因此我们需要一种方式来将这些观察空间的z值变换到[0, 1]范围之间。

- 线性深度缓冲
  ![image-20250427170858687](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250427170858687.png)


  线性深度缓冲有一个问题：不需要对1000单位远的深度值和只有1单位远的充满细节的物体使用相同的精度，最好是越近精度越高。

- 非线性精度缓冲
  ![image-20250427171057916](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250427171057916.png)
  在近距离的时候（z小的时候)，精度很高，观察空间中轻微的变化映射到深度缓冲中就是较大的变化。

### 深度冲突

两个平面共面或者很近的时候，深度缓冲没有足够的精度来决定两个形状哪个在前面，然后就会疯狂闪烁。

防止深度冲突：

- **永远不要把多个物体摆得太靠近，以至于它们的一些三角形会重叠**。

- **尽可能将近平面设置远一些**。在前面我们提到了精度在靠近**近**平面时是非常高的，所以如果我们将**近**平面远离观察者，我们将会对整个平截头体有着更大的精度。然而，将近平面设置太远将会导致近处的物体被裁剪掉，所以这通常需要实验和微调来决定最适合你的场景的**近**平面距离。

- 牺牲一些性能，**使用更高精度的深度缓冲**。

  