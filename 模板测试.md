### 模板测试

当片段着色器处理完一个片段之后，模板测试(Stencil Test)会开始执行，和深度测试一样，它也可能会丢弃片段

#### 目的

模板测试的目的：利用已经本次绘制的物体，产生一个区域，在下次绘制中利用这个区域做一些效果。

#### 操作

![image-20250428193203881](C:\Users\SOF\Desktop\OpenGL\assets\image-20250428193203881.png)

启用模板测试

![image-20250428193213079](C:\Users\SOF\Desktop\OpenGL\assets\image-20250428193213079.png)

每帧渲染的时候要清除上一帧的模板缓冲

![image-20250428193251453](C:\Users\SOF\Desktop\OpenGL\assets\image-20250428193251453.png)

模板缓冲的掩码，**写入**缓冲的所有模板值会和这些值相与（深度缓冲也有类似的mask）

### 模板函数

设置如何进行模板测试：

![image-20250428193822024](C:\Users\SOF\Desktop\OpenGL\assets\image-20250428193822024.png)

模板缓冲区的数据先和0xFF相与，然后等于1的值就通过模板测试（注意，这里的mask **影响片元能不能被画出来**，上面的mask**控制什么东西会写入模板缓冲**）

![image-20250428194316881](C:\Users\SOF\Desktop\OpenGL\assets\image-20250428194316881.png)



设置如何更新缓冲：

![image-20250428194646201](C:\Users\SOF\Desktop\OpenGL\assets\image-20250428194646201.png)



### 利用模板测试给物体画轮廓

首先启用模板测试，测试方式为：模板缓冲区的数据先和0xFF相与，然后等于1的值就通过模板测试，更新缓冲的方式为：当模板测试和深度测试都通过时，更新模板值为1（即$glStencilFunc$的第二个参数值）

![image-20250428194736200](C:\Users\SOF\Desktop\OpenGL\assets\image-20250428194736200.png)

然后使用第一个shader正常画地板，设置mask为0，就是禁用模板缓冲（只能写入0）

![image-20250428195742230](C:\Users\SOF\Desktop\OpenGL\assets\image-20250428195742230.png)

然后画立方体，设置为总是能够通过模板测试，然后通过模板测试时，更新模板值为1&0xFF

![image-20250428195704242](C:\Users\SOF\Desktop\OpenGL\assets\image-20250428195704242.png)

所以呢，使用$cubeVAO$画的立方体，他的片段内对应到屏幕空间中的模板缓冲都是1

然后换成另一个shader画轮廓：

![image-20250428200329505](C:\Users\SOF\Desktop\OpenGL\assets\image-20250428200329505.png)

不为1的都通过测试，同时不更新模板值。并且关闭了深度测试，也就是说，地板不会遮挡边框。

如果不关的话就会这样：

![image-20250428202544675](C:\Users\SOF\Desktop\OpenGL\assets\image-20250428202544675.png)

然后把立方体扩大到原来的1.1倍数，相当于只绘制立方体比原来大的地方（按理来说，这样的区域是一个空心的立方体，而不是一个“边框”，但是因为这个测试是在屏幕空间做的，原来的那个立方体在屏幕空间中出现的区域能够通过测试，不会参与这一轮的渲染，所以就是一个边框）

然后呢，画完两个立方体边框，再设置成全部通过测试，并且把模板缓冲写入成0（也就是全部模板缓冲恢复到0，否则的话保留到下一帧这个模板区域无法通过测试，就是这样：![image-20250428202705117](C:\Users\SOF\Desktop\OpenGL\assets\image-20250428202705117.png))



