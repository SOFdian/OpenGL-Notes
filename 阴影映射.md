![image-20250610114934263](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250610114934263.png)

一种思路是，从光源方向发出射线，遍历射线经过的所有点，只有最近的点在光照射下，其他都在阴影中，这种方法计算量很大

另一种思路如右图，当前渲染片段为`P`，从光源位置看向`P`，计算出一个深度值出来，这个计算是通过一个转置矩阵`T`，将当前坐标空间转换到一个光源的坐标空间来实现的

### 深度贴图

首先需要一个帧缓冲对象，用于绘制深度贴图

![image-20250610134114197](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250610134114197.png)

创建了一个2D纹理`depthMap`，指定纹理格式为`GL_DEPTH_COMPONENT`，即仅用于深度值

![image-20250610134129912](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250610134129912.png)

然后将`depthMap`附加到这个深度缓冲上，这样帧缓冲的结果会被绘制到`depthMap`上

因为不需要颜色数据，所以无需颜色缓冲，然而不包含颜色缓冲的帧缓冲对象是不完整的，所以需要显式告诉`OpenGL`不使用任何颜色数据进行渲染，即设置`glDrawBuffer`和`glReadBuffer`为`GL_NONE`

![image-20250610134137226](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250610134137226.png)

然后渲染深度贴图：

![image-20250610135404591](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250610135404591.png)

因为光线是平行光，所以这里使用了一个正交投影矩阵`glm::ortho`，同时用`glm::lookAt`获取观察矩阵，运算获得最终的变换矩阵`lightSpaceMatrix`，这个矩阵的作用是将每个世界空间坐标变换到光源处所见到的那个空间，以便计算这个空间下的深度，着色器如下

![image-20250610135746606](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250610135746606.png)

![image-20250610135800533](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250610135800533.png)

顶点着色器应用变换，片段着色器什么也不用做（深度缓冲会自己更新的，当然取消注释手动更新也行，但是效率没有自动更新高）

然后调用`glViewport`使得视口符合`depthMap`的分辨率，再渲染

![image-20250610141044091](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250610141044091.png)

然后画到一个2D的矩形上，注意这里需要重新设置一下`glViewport`

![image-20250610141033206](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250610141033206.png)
