首先就是，人眼对于暗色的分辨能力远超过亮色；

也就是说，亮色和暗色均匀分布的话，那亮色部分就会精度过剩而暗色部分就会精度不足。

![image-20250604110104391](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250604110104391.png)

如图所示，横轴是**物理亮度**（物理意义上，就是光子的数量多少）

红色虚线是**人眼感受亮度**，大致对应于**物理亮度**的1/2.2次方，**物理亮度**为0.218时**人眼感受亮度**为0.5

红色实线是**显示器亮度**，大致对应于**程序设置亮度**的2.2次方，**程序设置亮度**为0.5，**显示器亮度**为0.218

<<<<<<< HEAD
![image-20250604124238945](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250604124238945.png)

因此需要进行一个Gamma校正，这样**程序设置亮度**才符合**人眼感受亮度**
=======
因此导致了两个问题：

1.显示器实际亮度偏暗

2.显示器暗部细节少，不符合人眼在暗部的高精度特性

### 目的

由于程序**程序设置亮度**为$x$时，**显示器亮度**为$x^{2.2}$，会更加暗，因此需要把**程序设置亮度**$^{1/2.2}$

### Gamma校正

直接使用`OpenGL`的设置：

![image-20250605113722095](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250605113722095.png)

也可以在着色器中手动控制：

![image-20250605114056705](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250605114056705.png)

最好是在屏幕后处理着色器里面写，这样如果有多个不同物体的着色器时，不用单独写

![image-20250605114322125](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250605114322125.png)

### sRGB纹理

上面的结果实际上是做了两次伽马校正

创作者创作纹理的时候（如果在sRGB空间），此时没有伽马校正，但是它是对照显示器调试纹理颜色的，相当于人工进行了一次额外校正，因此设置纹理时需要这样：

![image-20250605114954513](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250605114954513.png)

设置为`GL_SRGB`：

![image-20250605115030120](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250605115030120.png)

没设置`sRGB`：

![image-20250605115044899](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250605115044899.png)

### 衰减

设置Gamma校正与否也会影响到光源表现，例如引入光线衰减之后：

![image-20250605115942757](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250605115942757.png)

有Gamma：

![image-20250607100950354](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250607100950354.png)

无Gamma：

![image-20250607100936146](C:\Users\SOF\Desktop\OpenGL笔记\assets\image-20250607100936146.png)

这种差异产生的原因是，光的衰减方程改变了亮度值，而且屏幕上显示出来的也不是线性空间，在显示器上效果最好的衰减方程，并不是符合物理的。想想平方衰减方程，如果我们使用这个方程，而且不进行gamma校正，显示在监视器上的衰减方程实际上将变成(1.0/distance2)2.2(1.0/distance2)2.2。若不进行gamma校正，将产生更强烈的衰减。这也解释了为什么双曲线不用gamma校正时看起来更真实，因为它实际变成了(1.0/distance)2.2=1.0/distance2.2(1.0/distance)2.2=1.0/distance2.2。这和物理公式是很相似的。
